{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ImportQualifiedPost #-}
module Lib.Entry where

import Control.Arrow (first, left)
import Data.ByteString.Lazy qualified as BL
import Data.Csv qualified as Csv
import Data.Either (partitionEithers)
import Data.Foldable qualified as Foldable
import Data.Function (on)
import Data.List qualified as L
import Data.Map (Map)
import Data.Map qualified as M
import Data.Map.Strict qualified as MS
import Data.Maybe (fromMaybe, catMaybes)
import Data.Maybe qualified as Maybe
import Data.Set (Set)
import Data.Set qualified as S
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Read as TR
import Data.Vector (Vector)
import Data.Vector qualified as V
import Data.Vector.NonEmpty (NonEmptyVector)
import Data.Vector.NonEmpty qualified as NEV
import GHC.Generics (Generic)
import Text.Printf (printf)

import Lib.Row

data Entry音義 = Entry音義
  { e_隋音 :: !Text
  , e_義 :: !(Maybe Text)
  }
  deriving (Read, Show, Eq, Ord, Generic)

data Entry音 = Entry音
  deriving (Read, Show, Eq, Ord, Generic)

-- Entry
data Entry = Entry
  { e_position :: !(Set Position)
  , e_字 :: !Text
  , e_shapeVariants :: !ShapeVariants
  , e_部畫 :: !(Maybe Shape部畫)
  , e_parts :: !Parts
  , e_音義 :: ![Entry音義]
  }
  deriving (Read, Show, Eq, Ord, Generic)

data Section = Section
  { sec_諧符位 :: !Int
  , sec_諧符部 :: !Text
  , sec_entries :: ![Entry]
  }
  deriving (Read, Show, Eq, Ord, Generic)

-- | Group items with key generated by the specified function
--
-- Examples

groupBy :: (Ord k) => (a -> k) -> [a] -> MS.Map k (NonEmptyVector a)
groupBy f xs = MS.unionsWith (<>) ms
  where
    ms = map (\x -> MS.singleton (f x) (NEV.singleton x)) xs

sectionsFromRows :: (Foldable f) => f Row -> ([String], [Section])
sectionsFromRows rs = first concat . unzip . map renderSection $ MS.toList sectionMap
  where
    sectionMap = groupBy (\r -> (p_諧符位 $ r_parts r, p_諧符部 $ r_parts r)) $ Foldable.toList rs
    renderSection (k, v) = (errors, section)
      where
        (errors, f_entries) = entriesFromRows $ NEV.toList v
        section = Section
                  { sec_諧符位 = fst k
                  , sec_諧符部 = snd k
                  , sec_entries = f_entries
                  }

entriesFromRows :: (Functor f, Foldable f) => f Row -> ([String], [Entry])
entriesFromRows rs = (errors, L.sortBy (compare `on` e_position) groupedEntries)
  where
    undedupedEntries = Foldable.toList $ fmap entryFromRow rs
    entriesByHeadword = MS.map (NEV.foldl1' liftedMergeEntry . NEV.map Right) $ groupBy e_字 undedupedEntries
    liftedMergeEntry :: Either String Entry -> Either String Entry -> Either String Entry
    liftedMergeEntry = (\ma mb -> ma >>= \a -> mb >>= \b -> mergeEntry a b)
    (errors, groupedEntries) = partitionEithers . map snd . MS.toList $ entriesByHeadword
    entryFromRow r = Entry
                     { e_position = S.singleton $ r_position r
                     , e_字 = r_字 r
                     , e_shapeVariants = r_shapeVariants r
                     , e_部畫 = r_部畫 r
                     , e_parts = r_parts r
                     , e_音義 = [Entry音義
                                 { e_隋音 = r_隋音 r
                                 , e_義 = r_義 r
                                 }]
                     }

compareAndTakeOne :: (Show pos, Eq b, Show b) => pos -> String -> (a -> b) -> a -> a -> Either String b
compareAndTakeOne pos label f a b =
  if f a == f b
  then Right $ f a
  else Left $ printf "%s: Mismatched %s: %s vs. %s" (show pos) label (show $ f a) (show $ f b)

mergeEntry :: Entry -> Entry -> Either String Entry
mergeEntry a b = do
  let f_position = e_position a <> e_position b
  f_字 <- compareAndTakeOne f_position "字" e_字 a b
  f_shapeVariants <- compareAndTakeOne f_position "shape variants" e_shapeVariants a b
  f_部畫 <- compareAndTakeOne f_position "部畫" e_部畫 a b
  f_parts <- compareAndTakeOne f_position "parts" e_parts a b
  let f_音義 = e_音義 a <> e_音義 b
  return $ Entry
    { e_position = f_position
    , e_字 = f_字
    , e_shapeVariants = f_shapeVariants
    , e_部畫 = f_部畫
    , e_parts = f_parts
    , e_音義 = f_音義
    }

variantToTex label [] pre = Nothing
variantToTex label shapes pre = Just $ mconcat
    [ label
    , "作"
    , T.intercalate "、" quoted
    ]
  where
    quoted = map (\x -> "“" <> pre <> "{" <> s_字 x <> "}”") shapes

shapeVariantsToTex :: ShapeVariants -> Text
shapeVariantsToTex s = mconcat
    [ "  ", renderSikrok . s_四角 . s_親 $ s
    , T.intercalate "，又" variantDescs
    ]
  where
    renderSikrok (sm, ss) = "\\Sikrok{" <> sm <> "}{" <> ss <> "}"
    variantDescs = Maybe.catMaybes $ map (\(l, c, p) -> variantToTex l c p)
      [ ("選\\footnote{what is 選?}", s_選 s, "")
      , ("簡", s_簡 s, "\\textHans") -- TODO Special case where Simplified and Japanese shapes are identical
      , ("日", s_日 s, "\\textJapn")
      , ("或", s_异 s, "") -- TODO
      ]

shape部畫ToTex :: Shape部畫 -> Text
shape部畫ToTex s = mconcat
  [ "（"
  , s_部 s
  , "部"
  , T.pack . show . s_畫 $ s
  , "畫）"
  ]

entryToTex :: Entry -> Text
entryToTex e = mconcat
    [ "\\noindent"
    , "\\Position{"
    , T.intercalate "; " . map (T.pack . printf "%d" . pos_row) . S.toList $ e_position e
    , "}"
    , "\n\n"
    , "\\begin{Entry}{", e_字 e, "}{", e_字 e, "}\n"
    -- , "  + 0（夊部0畫）\n"
    , fromMaybe "" . fmap shape部畫ToTex $ e_部畫 e
    , "  \\\\\n"
    , "  ", shapeVariantsToTex $ e_shapeVariants e, "\n"
    , "  \\begin{Sound}\n"
    , T.intercalate "\n" tex音Items
    , "\n"
    -- , "    \\SoundItem{toŋ}《P3798》都宗反，端冬平，上平聲二冬\n"
    , "  \\end{Sound}\n"
    , if null tex義Items
      then ""
      else "\\begin{Sense}\n" <> T.intercalate "\n" tex義Items <> "\n\\end{Sense}"
    , "\\end{Entry}\n"
    ]
  where
    tex音Items = map (\sp -> "\\SoundItem{" <> e_隋音 sp <> "}") $ e_音義 e
    tex義Items = catMaybes . map render義Item $ e_音義 e
    render義Item sp = do
      s <- e_義 sp
      return $ "\\SenseItem{" <> e_隋音 sp <> "}" <> s

sectionToTex :: Section -> Text
sectionToTex s = mconcat
    [ "\\PartHeader{"
    , sec_諧符部 s
    , "符"
    , "}{"
    , T.concat . map (\e -> "\\refEntry{" <> e_字 e <> "}") $ sec_entries s
    , "}"
    , T.intercalate "\n" . map entryToTex $ sec_entries s
    , "\n\n"
    ]
